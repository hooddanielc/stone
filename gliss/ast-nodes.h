#pragma once

namespace gliss {

namespace ast {

class variable_identifier_t;
class primary_expression_t;
class postfix_expression_t;
class postfix_expression_integer_array_t;
class postfix_expression_field_selection_t;
class postfix_expression_increment_t;
class postfix_expression_decrement_t;
class integer_expression_t;
class function_call_t;
class function_call_or_method_t;
class function_call_generic_t;
class function_call_header_no_parameters_t;
class function_call_header_void_parameter_t;
class function_call_header_with_parameters_t;
class function_call_header_t;
class function_identifier_t;
class unary_expression_t;
class unary_operator_t;
class multiplicative_expression_t;
class additive_expression_t;
class shift_expression_t;
class relational_expression_t;
class equality_expression_t;
class and_expression_t;
class exclusive_or_expression_t;
class inclusive_or_expression_t;
class logical_and_expression_t;
class logical_xor_expression_t;
class logical_or_expression_t;
class conditional_expression_t;
class conditional_ternary_expression_t;
class assignment_expression_t;
class assignment_operator_t;
class expression_t;
class constant_expression_t;
class declaration_t;
class type_qualifier_identifier_t;
class type_qualifier_terminated_t;
class type_qualifier_struct_declaration_list_identifier_array_t;
class type_qualifier_struct_declaration_list_identifier_t;
class type_qualifier_struct_declaration_list_t;
class identifier_list_t;
class function_prototype_t;
class function_declarator_t;
class function_header_with_parameters_t;
class function_header_t;
class parameter_declarator_t;
class parameter_declarator_array_t;
class parameter_declaration_t;
class parameter_type_specifier_t;
class init_declarator_list_t;
class init_declarator_list_initializer_t;
class init_declarator_list_array_initializer_t;
class init_declarator_list_array_t;
class single_declaration_t;
class fully_specified_type_initializer_t;
class fully_specified_type_identifier_array_initializer_t;
class fully_specified_type_identifier_array_t;
class fully_specified_type_identifier_t;
class fully_specified_type_t;
class invariant_qualifier_t;
class interpolation_qualifier_t;
class layout_qualifier_t;
class layout_qualifier_id_list_t;
class layout_qualifier_id_t;
class layout_qualifier_id_equal_constant_expression_t;
class precise_qualifier_t;
class type_qualifier_t;
class single_type_qualifier_t;
class storage_qualifier_t;
class storage_qualifier_subroutine_list_t;
class type_name_list_t;
class type_specifier_t;
class type_specifier_array_t;
class array_specifier_t;
class array_specifier_conditional_t;
class array_specifier_conditional_nested_t;
class type_specifier_nonarray_t;
class precision_qualifier_t;
class struct_specifier_t;
class struct_specifier_identifier_body_t;
class struct_specifier_body_t;
class struct_declaration_list_t;
class struct_declaration_t;
class struct_declarator_list_t;
class struct_declarator_t;
class struct_declarator_array_t;
class initializer_t;
class initializer_list_body_t;
class initializer_list_body_trailing_comma_t;
class initializer_list_t;
class declaration_statement_t;
class statement_t;
class simple_statement_t;
class compound_statement_t;
class compound_statement_list_t;
class statement_no_new_scope_t;
class compound_statement_no_new_scope_t;
class compound_statement_no_new_scope_list_t;
class statement_list_t;
class expression_statement_t;
class selection_statement_t;
class selection_rest_statement_t;
class selection_rest_statement_else_t;
class condition_t;
class switch_statement_t;
class switch_statement_list_t;
class nothing_t;
class case_label_t;
class iteration_statement_t;
class iteration_statement_while_header_t;
class iteration_statement_for_header_t;
class for_init_statement_t;
class conditionopt_t;
class for_rest_statement_t;
class for_rest_statement_expression_t;
class jump_statement_t;
class jump_statement_return_t;
class jump_statement_break_t;
class jump_statement_continue_t;
class translation_unit_t;
class external_declaration_t;
class function_definition_t;
class ast_t;

struct empty_visitor_t {
  virtual ~empty_visitor_t() = default;
};  // empty_visitor_t

struct default_visitor_t: public empty_visitor_t {
  virtual ~default_visitor_t() = default;
  virtual void operator()(const variable_identifier_t *) const = 0;
  virtual void operator()(const primary_expression_t *) const = 0;
  virtual void operator()(const postfix_expression_t *) const = 0;
  virtual void operator()(const postfix_expression_integer_array_t *) const = 0;
  virtual void operator()(const postfix_expression_field_selection_t *) const = 0;
  virtual void operator()(const postfix_expression_increment_t *) const = 0;
  virtual void operator()(const postfix_expression_decrement_t *) const = 0;
  virtual void operator()(const integer_expression_t *) const = 0;
  virtual void operator()(const function_call_t *) const = 0;
  virtual void operator()(const function_call_or_method_t *) const = 0;
  virtual void operator()(const function_call_generic_t *) const = 0;
  virtual void operator()(const function_call_header_no_parameters_t *) const = 0;
  virtual void operator()(const function_call_header_void_parameter_t *) const = 0;
  virtual void operator()(const function_call_header_with_parameters_t *) const = 0;
  virtual void operator()(const function_call_header_t *) const = 0;
  virtual void operator()(const function_identifier_t *) const = 0;
  virtual void operator()(const unary_expression_t *) const = 0;
  virtual void operator()(const unary_operator_t *) const = 0;
  virtual void operator()(const multiplicative_expression_t *) const = 0;
  virtual void operator()(const additive_expression_t *) const = 0;
  virtual void operator()(const shift_expression_t *) const = 0;
  virtual void operator()(const relational_expression_t *) const = 0;
  virtual void operator()(const equality_expression_t *) const = 0;
  virtual void operator()(const and_expression_t *) const = 0;
  virtual void operator()(const exclusive_or_expression_t *) const = 0;
  virtual void operator()(const inclusive_or_expression_t *) const = 0;
  virtual void operator()(const logical_and_expression_t *) const = 0;
  virtual void operator()(const logical_xor_expression_t *) const = 0;
  virtual void operator()(const logical_or_expression_t *) const = 0;
  virtual void operator()(const conditional_expression_t *) const = 0;
  virtual void operator()(const conditional_ternary_expression_t *) const = 0;
  virtual void operator()(const assignment_expression_t *) const = 0;
  virtual void operator()(const assignment_operator_t *) const = 0;
  virtual void operator()(const expression_t *) const = 0;
  virtual void operator()(const constant_expression_t *) const = 0;
  virtual void operator()(const declaration_t *) const = 0;
  virtual void operator()(const type_qualifier_identifier_t *) const = 0;
  virtual void operator()(const type_qualifier_terminated_t *) const = 0;
  virtual void operator()(const type_qualifier_struct_declaration_list_identifier_array_t *) const = 0;
  virtual void operator()(const type_qualifier_struct_declaration_list_identifier_t *) const = 0;
  virtual void operator()(const type_qualifier_struct_declaration_list_t *) const = 0;
  virtual void operator()(const identifier_list_t *) const = 0;
  virtual void operator()(const function_prototype_t *) const = 0;
  virtual void operator()(const function_declarator_t *) const = 0;
  virtual void operator()(const function_header_with_parameters_t *) const = 0;
  virtual void operator()(const function_header_t *) const = 0;
  virtual void operator()(const parameter_declarator_t *) const = 0;
  virtual void operator()(const parameter_declarator_array_t *) const = 0;
  virtual void operator()(const parameter_declaration_t *) const = 0;
  virtual void operator()(const parameter_type_specifier_t *) const = 0;
  virtual void operator()(const init_declarator_list_t *) const = 0;
  virtual void operator()(const init_declarator_list_initializer_t *) const = 0;
  virtual void operator()(const init_declarator_list_array_initializer_t *) const = 0;
  virtual void operator()(const init_declarator_list_array_t *) const = 0;
  virtual void operator()(const single_declaration_t *) const = 0;
  virtual void operator()(const fully_specified_type_initializer_t *) const = 0;
  virtual void operator()(const fully_specified_type_identifier_array_initializer_t *) const = 0;
  virtual void operator()(const fully_specified_type_identifier_array_t *) const = 0;
  virtual void operator()(const fully_specified_type_identifier_t *) const = 0;
  virtual void operator()(const fully_specified_type_t *) const = 0;
  virtual void operator()(const invariant_qualifier_t *) const = 0;
  virtual void operator()(const interpolation_qualifier_t *) const = 0;
  virtual void operator()(const layout_qualifier_t *) const = 0;
  virtual void operator()(const layout_qualifier_id_list_t *) const = 0;
  virtual void operator()(const layout_qualifier_id_t *) const = 0;
  virtual void operator()(const layout_qualifier_id_equal_constant_expression_t *) const = 0;
  virtual void operator()(const precise_qualifier_t *) const = 0;
  virtual void operator()(const type_qualifier_t *) const = 0;
  virtual void operator()(const single_type_qualifier_t *) const = 0;
  virtual void operator()(const storage_qualifier_t *) const = 0;
  virtual void operator()(const storage_qualifier_subroutine_list_t *) const = 0;
  virtual void operator()(const type_name_list_t *) const = 0;
  virtual void operator()(const type_specifier_t *) const = 0;
  virtual void operator()(const type_specifier_array_t *) const = 0;
  virtual void operator()(const array_specifier_t *) const = 0;
  virtual void operator()(const array_specifier_conditional_t *) const = 0;
  virtual void operator()(const array_specifier_conditional_nested_t *) const = 0;
  virtual void operator()(const type_specifier_nonarray_t *) const = 0;
  virtual void operator()(const precision_qualifier_t *) const = 0;
  virtual void operator()(const struct_specifier_t *) const = 0;
  virtual void operator()(const struct_specifier_identifier_body_t *) const = 0;
  virtual void operator()(const struct_specifier_body_t *) const = 0;
  virtual void operator()(const struct_declaration_list_t *) const = 0;
  virtual void operator()(const struct_declaration_t *) const = 0;
  virtual void operator()(const struct_declarator_list_t *) const = 0;
  virtual void operator()(const struct_declarator_t *) const = 0;
  virtual void operator()(const struct_declarator_array_t *) const = 0;
  virtual void operator()(const initializer_t *) const = 0;
  virtual void operator()(const initializer_list_body_t *) const = 0;
  virtual void operator()(const initializer_list_body_trailing_comma_t *) const = 0;
  virtual void operator()(const initializer_list_t *) const = 0;
  virtual void operator()(const declaration_statement_t *) const = 0;
  virtual void operator()(const statement_t *) const = 0;
  virtual void operator()(const simple_statement_t *) const = 0;
  virtual void operator()(const compound_statement_t *) const = 0;
  virtual void operator()(const compound_statement_list_t *) const = 0;
  virtual void operator()(const statement_no_new_scope_t *) const = 0;
  virtual void operator()(const compound_statement_no_new_scope_t *) const = 0;
  virtual void operator()(const compound_statement_no_new_scope_list_t *) const = 0;
  virtual void operator()(const statement_list_t *) const = 0;
  virtual void operator()(const expression_statement_t *) const = 0;
  virtual void operator()(const selection_statement_t *) const = 0;
  virtual void operator()(const selection_rest_statement_t *) const = 0;
  virtual void operator()(const selection_rest_statement_else_t *) const = 0;
  virtual void operator()(const condition_t *) const = 0;
  virtual void operator()(const switch_statement_t *) const = 0;
  virtual void operator()(const switch_statement_list_t *) const = 0;
  virtual void operator()(const nothing_t *) const = 0;
  virtual void operator()(const case_label_t *) const = 0;
  virtual void operator()(const iteration_statement_t *) const = 0;
  virtual void operator()(const iteration_statement_while_header_t *) const = 0;
  virtual void operator()(const iteration_statement_for_header_t *) const = 0;
  virtual void operator()(const for_init_statement_t *) const = 0;
  virtual void operator()(const conditionopt_t *) const = 0;
  virtual void operator()(const for_rest_statement_t *) const = 0;
  virtual void operator()(const for_rest_statement_expression_t *) const = 0;
  virtual void operator()(const jump_statement_t *) const = 0;
  virtual void operator()(const jump_statement_return_t *) const = 0;
  virtual void operator()(const jump_statement_break_t *) const = 0;
  virtual void operator()(const jump_statement_continue_t *) const = 0;
  virtual void operator()(const translation_unit_t *) const = 0;
  virtual void operator()(const external_declaration_t *) const = 0;
  virtual void operator()(const function_definition_t *) const = 0;
};  // default_visitor_t

}   // ast

}   // gliss
