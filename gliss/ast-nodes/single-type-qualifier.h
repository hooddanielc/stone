#pragma once

/**
 * DO NOT MODIFY - AUTO GENERATED BY "../scripts/gen_cpp_node_constants.js"
 */

#include <vector>
#include "../ast.h"
#include "storage-qualifier.h"
#include "layout-qualifier.h"
#include "precision-qualifier.h"
#include "interpolation-qualifier.h"
#include "invariant-qualifier.h"
#include "precise-qualifier.h"

/**
 * Patterns for single_type_qualifier
 *
 * 1. storage_qualifier
 * 2. layout_qualifier
 * 3. precision_qualifier
 * 4. interpolation_qualifier
 * 5. invariant_qualifier
 * 6. precise_qualifier
 */

namespace gliss {

namespace ast {

class storage_qualifier_t;
class layout_qualifier_t;
class precision_qualifier_t;
class interpolation_qualifier_t;
class invariant_qualifier_t;
class precise_qualifier_t;

class single_type_qualifier_t: public ast_t {

public:

  static constexpr int rules = 6;

  static constexpr int id = 259;

  virtual ~single_type_qualifier_t() = default;

};  // single_type_qualifier_t

class single_type_qualifier_storage_qualifier_t: public single_type_qualifier_t {

public:

  std::unique_ptr<storage_qualifier_t> storage_qualifier_0;

  single_type_qualifier_storage_qualifier_t(
    std::unique_ptr<storage_qualifier_t> &&storage_qualifier_0_
  ): storage_qualifier_0(std::move(storage_qualifier_0_)) {}

  virtual void accept(const visitor_t &visitor) const override {
    visitor(this);
  }

  static std::unique_ptr<single_type_qualifier_storage_qualifier_t> make(
    std::unique_ptr<storage_qualifier_t> &&storage_qualifier_0_
  ) {
    return std::make_unique<single_type_qualifier_storage_qualifier_t>(
      std::move(storage_qualifier_0_)
    );
  }

};  // single_type_qualifier_storage_qualifier_t

class single_type_qualifier_layout_qualifier_t: public single_type_qualifier_t {

public:

  std::unique_ptr<layout_qualifier_t> layout_qualifier_0;

  single_type_qualifier_layout_qualifier_t(
    std::unique_ptr<layout_qualifier_t> &&layout_qualifier_0_
  ): layout_qualifier_0(std::move(layout_qualifier_0_)) {}

  virtual void accept(const visitor_t &visitor) const override {
    visitor(this);
  }

  static std::unique_ptr<single_type_qualifier_layout_qualifier_t> make(
    std::unique_ptr<layout_qualifier_t> &&layout_qualifier_0_
  ) {
    return std::make_unique<single_type_qualifier_layout_qualifier_t>(
      std::move(layout_qualifier_0_)
    );
  }

};  // single_type_qualifier_layout_qualifier_t

class single_type_qualifier_precision_qualifier_t: public single_type_qualifier_t {

public:

  std::unique_ptr<precision_qualifier_t> precision_qualifier_0;

  single_type_qualifier_precision_qualifier_t(
    std::unique_ptr<precision_qualifier_t> &&precision_qualifier_0_
  ): precision_qualifier_0(std::move(precision_qualifier_0_)) {}

  virtual void accept(const visitor_t &visitor) const override {
    visitor(this);
  }

  static std::unique_ptr<single_type_qualifier_precision_qualifier_t> make(
    std::unique_ptr<precision_qualifier_t> &&precision_qualifier_0_
  ) {
    return std::make_unique<single_type_qualifier_precision_qualifier_t>(
      std::move(precision_qualifier_0_)
    );
  }

};  // single_type_qualifier_precision_qualifier_t

class single_type_qualifier_interpolation_qualifier_t: public single_type_qualifier_t {

public:

  std::unique_ptr<interpolation_qualifier_t> interpolation_qualifier_0;

  single_type_qualifier_interpolation_qualifier_t(
    std::unique_ptr<interpolation_qualifier_t> &&interpolation_qualifier_0_
  ): interpolation_qualifier_0(std::move(interpolation_qualifier_0_)) {}

  virtual void accept(const visitor_t &visitor) const override {
    visitor(this);
  }

  static std::unique_ptr<single_type_qualifier_interpolation_qualifier_t> make(
    std::unique_ptr<interpolation_qualifier_t> &&interpolation_qualifier_0_
  ) {
    return std::make_unique<single_type_qualifier_interpolation_qualifier_t>(
      std::move(interpolation_qualifier_0_)
    );
  }

};  // single_type_qualifier_interpolation_qualifier_t

class single_type_qualifier_invariant_qualifier_t: public single_type_qualifier_t {

public:

  std::unique_ptr<invariant_qualifier_t> invariant_qualifier_0;

  single_type_qualifier_invariant_qualifier_t(
    std::unique_ptr<invariant_qualifier_t> &&invariant_qualifier_0_
  ): invariant_qualifier_0(std::move(invariant_qualifier_0_)) {}

  virtual void accept(const visitor_t &visitor) const override {
    visitor(this);
  }

  static std::unique_ptr<single_type_qualifier_invariant_qualifier_t> make(
    std::unique_ptr<invariant_qualifier_t> &&invariant_qualifier_0_
  ) {
    return std::make_unique<single_type_qualifier_invariant_qualifier_t>(
      std::move(invariant_qualifier_0_)
    );
  }

};  // single_type_qualifier_invariant_qualifier_t

class single_type_qualifier_precise_qualifier_t: public single_type_qualifier_t {

public:

  std::unique_ptr<precise_qualifier_t> precise_qualifier_0;

  single_type_qualifier_precise_qualifier_t(
    std::unique_ptr<precise_qualifier_t> &&precise_qualifier_0_
  ): precise_qualifier_0(std::move(precise_qualifier_0_)) {}

  virtual void accept(const visitor_t &visitor) const override {
    visitor(this);
  }

  static std::unique_ptr<single_type_qualifier_precise_qualifier_t> make(
    std::unique_ptr<precise_qualifier_t> &&precise_qualifier_0_
  ) {
    return std::make_unique<single_type_qualifier_precise_qualifier_t>(
      std::move(precise_qualifier_0_)
    );
  }

};  // single_type_qualifier_precise_qualifier_t

}   // ast

}   // gliss
