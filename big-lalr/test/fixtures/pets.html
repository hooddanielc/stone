
        <!doctype html>
        <html>
          <head>
            <title>Grammar</title>
          </head>
          <body>
            <script id="json" type="application/json">
              {"actions":[{"actions":{"--":{"label":"r7","rule":7,"type":"reduce"},"c":{"label":"r7","rule":7,"type":"reduce"},"d":{"label":"r7","rule":7,"type":"reduce"}},"state":1,"transition":{"nothing":{"label":"s2","state":2,"type":"shift"},"pets":{"label":"s3","state":3,"type":"shift"}}},{"actions":{"--":{"label":"â†º","type":"restart"},"c":{"label":"s4","state":4,"type":"shift"},"d":{"label":"s5","state":5,"type":"shift"}},"state":3,"transition":{"pet":{"label":"s6","state":6,"type":"shift"}}},{"actions":{"--":{"label":"r2","rule":2,"type":"reduce"},"c":{"label":"r2","rule":2,"type":"reduce"},"d":{"label":"r2","rule":2,"type":"reduce"}},"state":6},{"actions":{"o":{"label":"s7","state":7,"type":"shift"}},"state":5},{"actions":{"g":{"label":"s8","state":8,"type":"shift"}},"state":7},{"actions":{"--":{"label":"r5","rule":5,"type":"reduce"},"c":{"label":"r5","rule":5,"type":"reduce"},"d":{"label":"r5","rule":5,"type":"reduce"}},"state":8},{"actions":{"a":{"label":"s9","state":9,"type":"shift"}},"state":4},{"actions":{"n":{"label":"s10","state":10,"type":"shift"},"t":{"label":"s11","state":11,"type":"shift"}},"state":9},{"actions":{"--":{"label":"r4","rule":4,"type":"reduce"},"c":{"label":"r4","rule":4,"type":"reduce"},"d":{"label":"r4","rule":4,"type":"reduce"}},"state":11},{"actions":{"a":{"label":"s12","state":12,"type":"shift"}},"state":10},{"actions":{"r":{"label":"s13","state":13,"type":"shift"}},"state":12},{"actions":{"y":{"label":"s14","state":14,"type":"shift"}},"state":13},{"actions":{"--":{"label":"r6","rule":6,"type":"reduce"},"c":{"label":"r6","rule":6,"type":"reduce"},"d":{"label":"r6","rule":6,"type":"reduce"}},"state":14},{"actions":{"--":{"label":"r3","rule":3,"type":"reduce"},"c":{"label":"r3","rule":3,"type":"reduce"},"d":{"label":"r3","rule":3,"type":"reduce"}},"state":2}],"cpp":{"ast.h":"class omega_branch_t;\nclass omega_from_pets_t;\nclass nothing_branch_t;\nclass nothing_as_epsilon_t;\nclass pets_branch_t;\nclass pets_from_pets_pet_t;\nclass pets_from_nothing_t;\nclass pet_branch_t;\nclass pet_from_c_a_t_t;\nclass pet_from_c_a_n_a_r_y_t;\nclass pet_from_d_o_g_t;\nclass ast_token_t;\n\n/* default visitor */\nstruct default_visitor_t {\n  virtual ~default_visitor_t() = default;\n  virtual void operator()(const omega_branch_t *) const = 0;\n  virtual void operator()(const omega_from_pets_t *) const = 0;\n  virtual void operator()(const nothing_branch_t *) const = 0;\n  virtual void operator()(const nothing_as_epsilon_t *) const = 0;\n  virtual void operator()(const pets_branch_t *) const = 0;\n  virtual void operator()(const pets_from_pets_pet_t *) const = 0;\n  virtual void operator()(const pets_from_nothing_t *) const = 0;\n  virtual void operator()(const pet_branch_t *) const = 0;\n  virtual void operator()(const pet_from_c_a_t_t *) const = 0;\n  virtual void operator()(const pet_from_c_a_n_a_r_y_t *) const = 0;\n  virtual void operator()(const pet_from_d_o_g_t *) const = 0;\n  virtual void operator()(const ast_token_t *) const = 0;\n};  // default_visitor_t\n\n\nclass ast_t;\n\n/* base class for all ast nodes */\nclass ast_t {\n\npublic:\n\n  using visitor_t = default_visitor_t;\n\n  virtual ~ast_t() = default;\n\n  /* famous out of the box visitor pattern functionality */\n  virtual void accept(const visitor_t &visitor) const = 0;\n\n  /* return all children */\n  std::vector<std::shared_ptr<ast_t>> get_children() const {\n    return children;\n  }\n\nprotected:\n\n  ast_t(std::vector<std::shared_ptr<ast_t>> children_): children(children_) {}\n\n  std::vector<std::shared_ptr<ast_t>> children;\n\n};  // ast_t\n\n/* an ast node holding a single token */\nclass ast_token_t: public ast_t {\n\npublic:\n\n  virtual void accept(const visitor_t &visitor) const override {\n    visitor(this);\n  }\n\n  static std::shared_ptr<ast_token_t> make(std::shared_ptr<token_t> token) {\n    auto ptr = new ast_token_t(token);\n    std::shared_ptr<ast_token_t> result(ptr);\n    return result;\n  }\n\nprotected:\n\n  std::shared_ptr<token_t> token;\n\n  ast_token_t(std::shared_ptr<token_t> token_): ast_t({}), token(token_) {\n    assert(children.size() == 0);\n  }\n\n};  // ast_token_t\n\n","parser_table.h":"\n\nenum action_kind_t {\n  restart = 1,\n  reduce = 2,\n  shift = 3,\n};\n\n// actions layout\n// {\n//   { token_id, { {state_id, {action_type, action_param}}, ... } ... },\n//   ...\n// }\n\n// transition layout\n// {\n//   { reduction_id, state_id },\n//   ...\n// }\n\nstatic const std::unordered_map<int, std::unordered_map<int, std::pair<int, int>>> actions = {\n  { 9, {\n    { 13, { 3, 14 } }\n  }},\n  { 8, {\n    { 12, { 3, 13 } }\n  }},\n  { 3, {\n    { 9, { 3, 11 } }\n  }},\n  { 4, {\n    { 2, { 2, 3 } },\n    { 3, { 3, 5 } },\n    { 1, { 2, 7 } },\n    { 8, { 2, 5 } },\n    { 6, { 2, 2 } },\n    { 11, { 2, 4 } },\n    { 14, { 2, 6 } }\n  }},\n  { 1, {\n    { 2, { 2, 3 } },\n    { 3, { 3, 4 } },\n    { 1, { 2, 7 } },\n    { 8, { 2, 5 } },\n    { 6, { 2, 2 } },\n    { 11, { 2, 4 } },\n    { 14, { 2, 6 } }\n  }},\n  { 5, {\n    { 5, { 3, 7 } }\n  }},\n  { 6, {\n    { 7, { 3, 8 } }\n  }},\n  { 2, {\n    { 10, { 3, 12 } },\n    { 4, { 3, 9 } }\n  }},\n  { 7, {\n    { 9, { 3, 10 } }\n  }}\n\n};   // actions\n  \n\nstatic std::unordered_map<int, int> transitions = {\n  { 12, 3 },\n  { 13, 1 },\n  { 11, 1 }\n\n};  // transition\n","reductions/nothing.h":"\n/* base class for nothing_branch */\nclass nothing_branch_t: public ast_t {\n\npublic:\n\n  static constexpr int symbol_id = 13;\n\nprotected:\n\n  nothing_branch_t(std::vector<std::shared_ptr<ast_t>> children): ast_t(children) {}\n\n};  // nothing_branch_t\n\nclass nothing_as_epsilon_t: public nothing_branch_t {\n\npublic:\n\n  static std::shared_ptr<nothing_as_epsilon_t> make(std::vector<std::shared_ptr<ast_t>> children) {\n    assert(children.size() == 0);\n    auto ptr = new nothing_as_epsilon_t(children);\n    std::shared_ptr<nothing_as_epsilon_t> result(ptr);\n    return result;\n  }\n\n  virtual void accept(const visitor_t &visitor) const override {\n    visitor(this);\n  }\n\n  static constexpr int rule_id = 7;\n\n  static const std::vector<symbol_t> pattern;\n\nprotected:\n\n  nothing_as_epsilon_t(std::vector<std::shared_ptr<ast_t>> children): nothing_branch_t(children) {}\n\n};  // nothing_as_epsilon_t\n\nconst std::vector<symbol_t> nothing_as_epsilon_t::pattern = { };\n\ntemplate <> struct reduction_lookup_t<7> {\n  using type = nothing_as_epsilon_t;\n};\n\n","reductions/pet.h":"\n/* base class for pet_branch */\nclass pet_branch_t: public ast_t {\n\npublic:\n\n  static constexpr int symbol_id = 12;\n\nprotected:\n\n  pet_branch_t(std::vector<std::shared_ptr<ast_t>> children): ast_t(children) {}\n\n};  // pet_branch_t\n\nclass pet_from_c_a_t_t: public pet_branch_t {\n\npublic:\n\n  static std::shared_ptr<pet_from_c_a_t_t> make(std::vector<std::shared_ptr<ast_t>> children) {\n    assert(children.size() == 3);\n    auto ptr = new pet_from_c_a_t_t(children);\n    std::shared_ptr<pet_from_c_a_t_t> result(ptr);\n    return result;\n  }\n\n  virtual void accept(const visitor_t &visitor) const override {\n    visitor(this);\n  }\n\n  static constexpr int rule_id = 4;\n\n  static const std::vector<symbol_t> pattern;\n\nprotected:\n\n  pet_from_c_a_t_t(std::vector<std::shared_ptr<ast_t>> children): pet_branch_t(children) {}\n\n};  // pet_from_c_a_t_t\n\nconst std::vector<symbol_t> pet_from_c_a_t_t::pattern = { c, a, t };\n\ntemplate <> struct reduction_lookup_t<4> {\n  using type = pet_from_c_a_t_t;\n};\n\n\nclass pet_from_c_a_n_a_r_y_t: public pet_branch_t {\n\npublic:\n\n  static std::shared_ptr<pet_from_c_a_n_a_r_y_t> make(std::vector<std::shared_ptr<ast_t>> children) {\n    assert(children.size() == 6);\n    auto ptr = new pet_from_c_a_n_a_r_y_t(children);\n    std::shared_ptr<pet_from_c_a_n_a_r_y_t> result(ptr);\n    return result;\n  }\n\n  virtual void accept(const visitor_t &visitor) const override {\n    visitor(this);\n  }\n\n  static constexpr int rule_id = 6;\n\n  static const std::vector<symbol_t> pattern;\n\nprotected:\n\n  pet_from_c_a_n_a_r_y_t(std::vector<std::shared_ptr<ast_t>> children): pet_branch_t(children) {}\n\n};  // pet_from_c_a_n_a_r_y_t\n\nconst std::vector<symbol_t> pet_from_c_a_n_a_r_y_t::pattern = { c, a, n, a, r, y };\n\ntemplate <> struct reduction_lookup_t<6> {\n  using type = pet_from_c_a_n_a_r_y_t;\n};\n\n\nclass pet_from_d_o_g_t: public pet_branch_t {\n\npublic:\n\n  static std::shared_ptr<pet_from_d_o_g_t> make(std::vector<std::shared_ptr<ast_t>> children) {\n    assert(children.size() == 3);\n    auto ptr = new pet_from_d_o_g_t(children);\n    std::shared_ptr<pet_from_d_o_g_t> result(ptr);\n    return result;\n  }\n\n  virtual void accept(const visitor_t &visitor) const override {\n    visitor(this);\n  }\n\n  static constexpr int rule_id = 5;\n\n  static const std::vector<symbol_t> pattern;\n\nprotected:\n\n  pet_from_d_o_g_t(std::vector<std::shared_ptr<ast_t>> children): pet_branch_t(children) {}\n\n};  // pet_from_d_o_g_t\n\nconst std::vector<symbol_t> pet_from_d_o_g_t::pattern = { d, o, g };\n\ntemplate <> struct reduction_lookup_t<5> {\n  using type = pet_from_d_o_g_t;\n};\n\n","reductions/pets.h":"\n/* base class for pets_branch */\nclass pets_branch_t: public ast_t {\n\npublic:\n\n  static constexpr int symbol_id = 11;\n\nprotected:\n\n  pets_branch_t(std::vector<std::shared_ptr<ast_t>> children): ast_t(children) {}\n\n};  // pets_branch_t\n\nclass pets_from_pets_pet_t: public pets_branch_t {\n\npublic:\n\n  static std::shared_ptr<pets_from_pets_pet_t> make(std::vector<std::shared_ptr<ast_t>> children) {\n    assert(children.size() == 2);\n    auto ptr = new pets_from_pets_pet_t(children);\n    std::shared_ptr<pets_from_pets_pet_t> result(ptr);\n    return result;\n  }\n\n  virtual void accept(const visitor_t &visitor) const override {\n    visitor(this);\n  }\n\n  static constexpr int rule_id = 2;\n\n  static const std::vector<symbol_t> pattern;\n\nprotected:\n\n  pets_from_pets_pet_t(std::vector<std::shared_ptr<ast_t>> children): pets_branch_t(children) {}\n\n};  // pets_from_pets_pet_t\n\nconst std::vector<symbol_t> pets_from_pets_pet_t::pattern = { pets, pet };\n\ntemplate <> struct reduction_lookup_t<2> {\n  using type = pets_from_pets_pet_t;\n};\n\n\nclass pets_from_nothing_t: public pets_branch_t {\n\npublic:\n\n  static std::shared_ptr<pets_from_nothing_t> make(std::vector<std::shared_ptr<ast_t>> children) {\n    assert(children.size() == 1);\n    auto ptr = new pets_from_nothing_t(children);\n    std::shared_ptr<pets_from_nothing_t> result(ptr);\n    return result;\n  }\n\n  virtual void accept(const visitor_t &visitor) const override {\n    visitor(this);\n  }\n\n  static constexpr int rule_id = 3;\n\n  static const std::vector<symbol_t> pattern;\n\nprotected:\n\n  pets_from_nothing_t(std::vector<std::shared_ptr<ast_t>> children): pets_branch_t(children) {}\n\n};  // pets_from_nothing_t\n\nconst std::vector<symbol_t> pets_from_nothing_t::pattern = { nothing };\n\ntemplate <> struct reduction_lookup_t<3> {\n  using type = pets_from_nothing_t;\n};\n\n","symbol.h":"enum symbol_t {\n    y,\n    r,\n    n,\n    a,\n    c,\n    g,\n    t,\n    d,\n    o,\n    nothing,\n    pets,\n    pet,\n    omega\n};   // symbol_t\n\n\ntemplate <symbol_t type>\nstruct symbol_description_t {\n\n  static std::string get_name();\n\n  static bool is_terminal();\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<y> {\n\n  static std::string get_name() {\n    return \"y\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<r> {\n\n  static std::string get_name() {\n    return \"r\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<n> {\n\n  static std::string get_name() {\n    return \"n\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<a> {\n\n  static std::string get_name() {\n    return \"a\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<c> {\n\n  static std::string get_name() {\n    return \"c\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<g> {\n\n  static std::string get_name() {\n    return \"g\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<t> {\n\n  static std::string get_name() {\n    return \"t\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<d> {\n\n  static std::string get_name() {\n    return \"d\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<o> {\n\n  static std::string get_name() {\n    return \"o\";\n  }\n\n  static bool is_terminal() {\n    return true;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<nothing> {\n\n  static std::string get_name() {\n    return \"nothing\";\n  }\n\n  static bool is_terminal() {\n    return false;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<pets> {\n\n  static std::string get_name() {\n    return \"pets\";\n  }\n\n  static bool is_terminal() {\n    return false;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<pet> {\n\n  static std::string get_name() {\n    return \"pet\";\n  }\n\n  static bool is_terminal() {\n    return false;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <>\nstruct symbol_description_t<omega> {\n\n  static std::string get_name() {\n    return \"omega\";\n  }\n\n  static bool is_terminal() {\n    return false;\n  }\n\n};   // symbol_description_t<symbol_t>\n\n\n\ntemplate <int id>\nstruct reduction_lookup_t {};\n\n","token.h":"class token_t {\n\npublic:\n\n  enum kind_t {\n    y,\n    r,\n    n,\n    a,\n    c,\n    g,\n    t,\n    d,\n    o,\n  };   // kind_t\n\n  kind_t get_kind() {\n    return kind;\n  }\n\n  std::string get_name() {\n    switch(kind) {\n      case y: return \"y\";\n      case r: return \"r\";\n      case n: return \"n\";\n      case a: return \"a\";\n      case c: return \"c\";\n      case g: return \"g\";\n      case t: return \"t\";\n      case d: return \"d\";\n      case o: return \"o\";\n    }\n    return \"unknown\";\n  }\n\n  static std::shared_ptr<token_t> make(kind_t kind) {\n    auto ptr = new token_t(kind);\n    std::shared_ptr<token_t> result(ptr);\n    return result;\n  }\n\nprotected:\n\n  /* Cache the kind. */\n  token_t(kind_t kind): kind(kind) {}\n\n  kind_t kind;\n\n};   // token_t\n"},"dot":"digraph {\n  label=<<i>Diagram of State Machine</i>>\n  r2 [shape=diamond, label=<r2 (pets, 2)>];\n  r1 [shape=diamond, label=<r1 (&Omega;, 1)>];\n  r3 [shape=diamond, label=<r3 (pets, 1)>];\n  r7 [shape=diamond, label=<r7 (nothing, 0)>];\n  r4 [shape=diamond, label=<r4 (pet, 3)>];\n  r6 [shape=diamond, label=<r6 (pet, 6)>];\n  r5 [shape=diamond, label=<r5 (pet, 3)>];\n  s1 [shape=circle, label=<s1>];\n  s3 [shape=circle, label=<s3>];\n  s6 [shape=circle, label=<s6>];\n  s5 [shape=circle, label=<s5>];\n  s7 [shape=circle, label=<s7>];\n  s8 [shape=circle, label=<s8>];\n  s4 [shape=circle, label=<s4>];\n  s9 [shape=circle, label=<s9>];\n  s11 [shape=circle, label=<s11>];\n  s10 [shape=circle, label=<s10>];\n  s12 [shape=circle, label=<s12>];\n  s13 [shape=circle, label=<s13>];\n  s14 [shape=circle, label=<s14>];\n  s2 [shape=circle, label=<s2>];\n  r7 -> s1 [label=<&laquo;c&raquo;>, arrowhead=inv];\n  r7 -> s1 [label=<&laquo;d&raquo;>, arrowhead=inv];\n  r7 -> s1 [label=<&laquo;--&raquo;>, arrowhead=inv];\n  s1 -> s2 [label=<nothing>, style=dotted];\n  s1 -> s3 [label=<pets>, style=dotted];\n  s3 -> s4 [label=<&laquo;c&raquo;>];\n  s3 -> s5 [label=<&laquo;d&raquo;>];\n  r1 -> s3 [label=<&laquo;--&raquo;>, arrowhead=inv];\n  s3 -> s6 [label=<pet>, style=dotted];\n  r2 -> s6 [label=<&laquo;c&raquo;>, arrowhead=inv];\n  r2 -> s6 [label=<&laquo;d&raquo;>, arrowhead=inv];\n  r2 -> s6 [label=<&laquo;--&raquo;>, arrowhead=inv];\n  s5 -> s7 [label=<&laquo;o&raquo;>];\n  s7 -> s8 [label=<&laquo;g&raquo;>];\n  r5 -> s8 [label=<&laquo;c&raquo;>, arrowhead=inv];\n  r5 -> s8 [label=<&laquo;d&raquo;>, arrowhead=inv];\n  r5 -> s8 [label=<&laquo;--&raquo;>, arrowhead=inv];\n  s4 -> s9 [label=<&laquo;a&raquo;>];\n  s9 -> s10 [label=<&laquo;n&raquo;>];\n  s9 -> s11 [label=<&laquo;t&raquo;>];\n  r4 -> s11 [label=<&laquo;c&raquo;>, arrowhead=inv];\n  r4 -> s11 [label=<&laquo;d&raquo;>, arrowhead=inv];\n  r4 -> s11 [label=<&laquo;--&raquo;>, arrowhead=inv];\n  s10 -> s12 [label=<&laquo;a&raquo;>];\n  s12 -> s13 [label=<&laquo;r&raquo;>];\n  s13 -> s14 [label=<&laquo;y&raquo;>];\n  r6 -> s14 [label=<&laquo;c&raquo;>, arrowhead=inv];\n  r6 -> s14 [label=<&laquo;d&raquo;>, arrowhead=inv];\n  r6 -> s14 [label=<&laquo;--&raquo;>, arrowhead=inv];\n  r3 -> s2 [label=<&laquo;c&raquo;>, arrowhead=inv];\n  r3 -> s2 [label=<&laquo;d&raquo;>, arrowhead=inv];\n  r3 -> s2 [label=<&laquo;--&raquo;>, arrowhead=inv];\n}\n","reductions":{"nothing":{"id":13,"terminal":false},"pet":{"id":12,"terminal":false},"pets":{"id":11,"terminal":false}},"rules":[{"id":2,"lhs":"pets","rhs":["pets","pet"]},{"id":1,"lhs":"TOP","rhs":["pets"]},{"id":3,"lhs":"pets","rhs":["nothing"]},{"id":7,"lhs":"nothing"},{"id":4,"lhs":"pet","rhs":["c","a","t"]},{"id":6,"lhs":"pet","rhs":["c","a","n","a","r","y"]},{"id":5,"lhs":"pet","rhs":["d","o","g"]}],"tokens":{"--":{"id":14,"terminal":true},"a":{"id":2,"terminal":true},"c":{"id":1,"terminal":true},"d":{"id":4,"terminal":true},"g":{"id":6,"terminal":true},"n":{"id":7,"terminal":true},"o":{"id":5,"terminal":true},"r":{"id":8,"terminal":true},"t":{"id":3,"terminal":true},"y":{"id":9,"terminal":true}}}
            </script>
            <script src="pets.js" type="text/javascript"></script>
          </body>
        </html>
      